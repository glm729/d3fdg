// NOTE:
// The following section was generated by an external Ruby script.
// Caution is advised if modifying the contents.

/*** Function definitions ***/

function cleanNames(data, key = "name") {
  let result = [];
  let i = 0;
  data.map(d => {
    let keys = Object.keys(d).filter(x => x !== key);
    let nameClean = d[key]
      .toLowerCase()
      .replace(/\**( \(.+)?$/, '')
      .replace(/(ate|ic acid)$/, "ate");
    if (nameClean.match(/[\/\+]/) !== null) {
      let nameCleanMany = nameClean.split(/[\/\+]/).map(x => {
        return x.replace(/^\s+|\s+$/g, '');
      });
      nameCleanMany.map(x => {
        result.push(new Object());
        result[i][key] = x;
        keys.map(k => result[i][k] = d[k]);
        i += 1;
      });
    } else {
      result.push(new Object());
      result[i][key] = nameClean;
      keys.map(k => result[i][k] = d[k]);
      i += 1;
    };
  });
  return result;
};

function convRawTsvJson(raw, header = true) {
  let result = [];
  let head;
  let split = raw
    .replace(/\n$/, '')
    .split(/\n/)
    .map(x => x.replace(/\r/g, '').split(/\t/));
  head = header ? split.shift() : assignEmptyHeader(split[0].length);
  for (let s = 0; s < split.length; ++s) {
    result.push(new Object());
    for (let h = 0; h < head.length; ++h) {
      result[s][head[h]] = split[s][h];
    };
  };
  return result;
};

function getAllCompounds(withId, slr) {
  let idinWith = withId.map(w => w.idAnchor);
  let idinSlr = [...new Set(slr.map(s => [s.lhs, s.rhs]).flat())];
  idinSlr = idinSlr.filter(x => idinWith.indexOf(x) === -1);
  let output = new Array();
  withId.forEach(w => {
    let d = w;
    d.nodeCore = true;
    output.push(d);
  });
  idinSlr.forEach(i => {
    output.push({name: i, idAnchor: i, nodeCore: false, nodeColour: "grey"});
  });
  return output;
};

function getWithId(data, klc) {
  let result = [];
  let i = 0;
  data.map(d => {
    let extract = subsetData(d.name, klc);
    let idScan = pickAnchor(d.name, extract);
    if (idScan.idAnchor !== null) {
      result.push(d);
      result[i].idAnchor = idScan.idAnchor;
      result[i].idOther = idScan.idOther;
      i += 1;
    };
  });
  return result;
};

function numLinks(obj, slr) {
  let n = 0;
  slr.forEach(e => {
    if (e.lhs === obj.idAnchor || e.rhs === obj.idAnchor) n += 1;
  });
  obj.n = n
  return obj;
};

function pickAnchor(name, keggExtract) {
  let ida = null;
  let ido = [];
  let pat = {};
  let match = {"e": [], "l": [], "d": []};
  let patB = name.replace(/(ate|ic acid)$/, "(ate|ic acid)");
  pat.e = new RegExp("^" + patB + "$", "gi");
  pat.l = new RegExp("^l-" + patB + "$", "gi");
  pat.d = new RegExp("^d-" + patB + "$", "gi");
  keggExtract.map(k => {
    k.matchName.map(n => {
      if (n.match(pat.e) !== null) match.e.push(k.idKegg);
      if (n.match(pat.l) !== null) match.l.push(k.idKegg);
      if (n.match(pat.d) !== null) match.d.push(k.idKegg);
    });
  });
  if (match.e.length > 0) {
    if (match.e.length > 1) {
      let idt = match.e.sort();
      ida = idt.shift();
      idt.map(i => ido.push(i));
    } else {
      ida = match.e[0];
    };
  };
  if (match.l.length > 0) {
    if (ida === null) {
      if (match.l.length > 1) {
        let idt = match.l.sort();
        ida = idt.shift();
        idt.map(i => ido.push(i));
      } else {
        ida = match.l[0];
      };
    } else {
      match.l.map(m => ido.push(m));
    };
  };
  if (match.d.length > 0) {
    if (ida === null) {
      if (match.d.length > 1) {
        let idt = match.d.sort();
        ida = idt.shift();
        idt.map(i => ido.push(i));
      } else {
        ida = match.d[0];
      };
    } else {
      match.d.map(m => ido.push(m));
    };
  };
  while (ido.includes(ida)) ido.pop(ido.indexOf(ida));
  if (ido.length === 0) ido = null;
  return {"name": name, "idAnchor": ida, "idOther": ido};
};

function reduceShortlist(reacShortlist) {
  let reduced = new Array();
  reacShortlist.forEach(reac => {
    if (reac.lhs === reac.rhs) return;
    let add = true;
    reduced.forEach(red => {
      if (red.lhs === reac.lhs && red.rhs === reac.rhs) add = false;
      if (red.rhs === reac.lhs && red.lhs === reac.rhs) add = false;
    });
    if (add) reduced.push(reac);
  });
  return reduced;
};

function runSimulation(data, idSvg = "svgGraph", opt = {}) {
  function applyDefaults(input, defaults) {
    for (let k in defaults) {
      if (!input[k]) input[k] = defaults[k];
    };
    return input;
  };
  let defs = {
    cb_nodeColour: function(d, i) {
      return "cyan";
    },
    cb_nodeSize: function(d, i) {
      return 5;
    },
    cb_text: function(d, i) {
      return d.idAnchor;
    }
  };
  let _opt = applyDefaults(opt, defs);
  function drag(sim) {
    function dragStart(e, d) {
      if (!e.active) sim.alphaTarget(0.4).restart();
      d.fx = d.x;
      d.fy = d.y;
    };
    function dragging(e, d) {
      d.fx = e.x;
      d.fy = e.y;
    };
    function dragEnd(e, d) {
      if (!e.active) sim.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    };
    return d3.drag()
      .on("start", dragStart)
      .on("drag", dragging)
      .on("end", dragEnd);
  };
  function genTranslate(a, b) {
    return `translate(${a}, ${b})`;
  };
  function isConnected(a, b) {
    let check1 = indexLink[`${a.index}|${b.index}`];
    let check2 = indexLink[`${b.index}|${a.index}`];
    return (check1 || check2);
  };
  function simulationTick() {
    link
      .attr("x1", d => d.source.x)
      .attr("x2", d => d.target.x)
      .attr("y1", d => d.source.y)
      .attr("y2", d => d.target.y);
    node.attr("transform", d => genTranslate(d.x, d.y));
    text.attr("transform", (d, i) => {
      let off = {
        x: +document.querySelector(`#node${i}`).getAttribute("r") + 2,
        y: 2.5
      };
      return genTranslate(d.x + off.x, d.y + off.y);
    });
  };
  function zoomed({transform}) {
    g.attr("transform", transform);
  };
  let opacity = 0.15;
  let indexLink = new Object();
  let svgElement = document.getElementById(idSvg);
  let width = svgElement.width.baseVal.value;
  let height = svgElement.height.baseVal.value;
  let svg = d3.select(`#${idSvg}`)
    .attr("viewBox", [-width / 2, -height / 2, width, height])
    .attr("cursor", "move");
  let g = svg.append("g")
    .attr("cursor", "grab");
  let nodes = data.nodes.map(d => Object.create(d));
  let links = data.links.map(d => Object.create(d));
  let simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.idAnchor).iterations(2))
    .force("charge", d3.forceManyBody().strength(-110))
    .force("x", d3.forceX())
    .force("y", d3.forceY())
    .force("collide", d3.forceCollide().radius(5).iterations(2));
  let link = g.append("g")
      .attr("stroke", "#999")
      .attr("stroke-opacity", 0.7)
      .attr("pointer-events", "none")
    .selectAll(".link")
    .data(links)
    .join("line")
      .attr("stroke-width", 1)
      .attr("class", "link")
      .attr("id", (d, i) => `link_f${d.source.index}_t${d.target.index}_`);
  let node = g.append("g")
      .attr("stroke", "black")
      .attr("stroke-width", 1.2)
    .selectAll(".node")
    .data(nodes)
    .join("circle")
      .attr("r", (d, i) => _opt.cb_nodeSize(d, i))
      .attr("fill", (d, i) => _opt.cb_nodeColour(d, i))
      .attr("class", "node")
      .attr("id", (d, i) => `node${i}`)
      .call(drag(simulation));
  let text = g.append("g")
      .attr("visibility", "hidden")
      .attr("pointer-events", "none")
      .attr("font-size", "7px")
      .attr("text-anchor", "start")
    .selectAll(".text")
    .data(nodes)
    .join("text")
      .text((d, i) => _opt.cb_text(d, i))
      .attr("class", "text")
      .attr("id", (d, i) => `text${i}`);
  svg
    .call(
      d3.zoom()
        .extent([[0, 0], [width, height]])
        .scaleExtent([1 / 2, 8])
        .on("zoom", zoomed)
    );
  links.map(l => indexLink[`${l.source.index}|${l.target.index}`] = true);
  simulation.on("tick", simulationTick);
};

function shortlistReactions(input, kre) {
  function cb(id) {
    if (allIds.indexOf(id) === -1) allIds.push(id);
  };
  let allIds = new Array();
  input.forEach(i => {
    cb(i.idAnchor);
    if (i.idOther) i.idOther.forEach(cb);
  });
  let shortlist = new Array();
  kre.forEach(k => {
    k.lhs.forEach(l => {
      if (allIds.indexOf(l) !== -1) {
        k.rhs.forEach(r => {
          shortlist.push({lhs: l, rhs: r});
        });
      };
    });
    k.rhs.forEach(r => {
      if (allIds.indexOf(r) !== -1) {
        k.lhs.forEach(l => {
          shortlist.push({lhs: l, rhs: r});
        });
      };
    });
  });
  return shortlist;
};

function subsetData(name, keggData) {
  let nPat = name.replace(/(ate|ic acid)$/, "(ate|ic acid)");
  let nRex = new RegExp("^([dl]-)?" + nPat + "$", "gi");
  return keggData.map(k => {
    let anyMatch = k.nameKegg.filter(n => nRex.test(n))
    if (anyMatch.length === 0) return;
    return {"idKegg": k.idKegg, "matchName": anyMatch};
  }).filter(x => x !== undefined);
};

function swapOtherIds(input, reacShortlist) {
  let idPair = new Array();
  let otherIds = new Array();
  input.forEach(i => {
    if (i.idOther) {
      i.idOther.forEach(o => {
        idPair.push({idAnchor: i.idAnchor, idOther: o})
        otherIds.push(o);
      });
    };
  });
  reacShortlist.forEach(r => {
    if (otherIds.indexOf(r.lhs) !== -1) {
      r.lhs = idPair.filter(x => x.idOther === r.lhs)[0].idAnchor;
    };
    if (otherIds.indexOf(r.rhs) !== -1) {
      r.rhs = idPair.filter(x => x.idOther === r.rhs)[0].idAnchor;
    };
  });
  return reacShortlist;
};
