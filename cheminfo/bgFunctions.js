// NOTE:
// This Object was automatically generated by an external Ruby script.
// Caution is advised if modifying the contents.
let functions = {
  convRawTsvJson: function(raw, header = true) {
    let result = [];
    let head;
    let split = raw
      .replace(/\n$/, '')
      .split(/\n/)
      .map(x => x.replace(/\r/g, '').split(/\t/));
    head = header ? split.shift() : this.assignEmptyHeader(split[0].length);
    for (let s = 0; s < split.length; ++s) {
      result.push(new Object());
      for (let h = 0; h < head.length; ++h) {
        result[s][head[h]] = split[s][h];
      };
    };
    return result;
  },
  pickAnchor: function(name, keggExtract) {
    let ida = null;
    let ido = [];
    let pat = {};
    let match = {"e": [], "l": [], "d": []};
    let patB = name.replace(/(ate|ic acid)$/, "(ate|ic acid)");
    pat.e = new RegExp("^" + patB + "$", "g");
    pat.l = new RegExp("^l-" + patB + "$", "g");
    pat.d = new RegExp("^d-" + patB + "$", "g");
    keggExtract.map(k => {
      k.matchName.map(n => {
        if (n.match(pat.e) !== null) match.e.push(k.idKegg);
        if (n.match(pat.l) !== null) match.l.push(k.idKegg);
        if (n.match(pat.d) !== null) match.d.push(k.idKegg);
      });
    });
    if (match.e.length > 0) {
      if (match.e.length > 1) {
        let idt = match.e.sort();
        ida = idt.shift();
        idt.map(i => ido.push(i));
      } else {
        ida = match.e[0];
      };
    };
    if (match.l.length > 0) {
      if (ida === null) {
        if (match.l.length > 1) {
          let idt = match.l.sort();
          ida = idt.shift();
          idt.map(i => ido.push(i));
        } else {
          ida = match.l[0];
        };
      } else {
        match.l.map(m => ido.push(m));
      };
    };
    if (match.d.length > 0) {
      if (ida === null) {
        if (match.d.length > 1) {
          let idt = match.d.sort();
          ida = idt.shift();
          idt.map(i => ido.push(i));
        } else {
          ida = match.d[0];
        };
      } else {
        match.d.map(m => ido.push(m));
      };
    };
    while (ido.includes(ida)) ido.pop(ido.indexOf(ida));
    if (ido.length === 0) ido = null;
    return {"name": name, "idAnchor": ida, "idOther": ido};
  },
  assignEmptyHeader: function(ofLength) {
    let result = [];
    for (let i = 0; i < ofLength; ++i) {
      result.push("v" + String(i).padStart(String(ofLength).length, "0"));
    };
    return result;
  },
  reduceUniqueNames: function(data, key = "name") {
    let result = [];
    let nameUniq = [];
    data.map(d => {
      let keys = Object.keys(d).filter(x => x !== key);
      d[key] = d[key].toLowerCase();
      if (nameUniq.indexOf(d[key]) === -1) {
        nameUniq.push(d[key]);
        result.push(new Object());
        let i = nameUniq.indexOf(d[key]);
        result[i][key] = d[key];
        result[i].timesReported = 1;
        keys.map(k => {
          result[i][k] = [];
          result[i][k].push(d[k]);
        });
      } else {
        let i = nameUniq.indexOf(d[key]);
        result[i].timesReported += 1;
        keys.map(k => result[i][k].push(d[k]));
      };
    });
    return result;
    result.map(r => {
      let keys = Object
        .keys(r)
        .filter(x => x !== key && x !== "timesReported");
      keys.map(k => {
        let toReplace = [...new Set(r[k])].sort();
        r[k] = (toReplace.length === 1) ? toReplace[0] : toReplace;
      });
    });
  },
  convKeggListCompound: function(raw) {
    let data = raw.replace(/\n$/, '').split(/\n/).map(r => r.split(/\t/));
    return data.map(d => {
      return {
        "idKegg": d[0].replace(/^cpd:/, ''),
        "nameKegg": d[1].split(/; /).map(n => n.toLowerCase())
      };
    });
  },
  reduceOppose: function(withId, oppose) {
    let result = [];
    oppose.map(o => {
      withId.map(w => {
        if (w.idOther === null) return;
        if (w.idOther.indexOf(o.lhs) !== -1) o.lhs = w.idAnchor;
        if (w.idOther.indexOf(o.rhs) !== -1) o.rhs = w.idAnchor;
      });
      if (o.lhs === o.rhs) return;
      let isPresent = false;
      result.map(r => {
        if (r.lhs === o.lhs && r.rhs === o.rhs) isPresent = true;
        if (r.rhs === o.lhs && r.lhs === o.rhs) isPresent = true;
        if (isPresent) return;
      })
      if (!isPresent) result.push(o);
    });
    return result;
  },
  getOppose: function(withId, kre) {
    let result = [];
    let idAll = withId
      .map(w => {
        return [w.idAnchor, w.idOther].flat();
      })
      .flat()
      .filter(x => x !== null)
    let idUniq = [...new Set(idAll)];
    kre.map(k => {
      let lhsIn = k.lhs.map(l => {
        if (idUniq.indexOf(l) !== -1) return l;
      }).filter(l => l !== undefined);
      if (lhsIn.length === 0) return;
      let rhsIn = k.rhs.map(r => {
        if (idUniq.indexOf(r) !== -1) return r;
      }).filter(r => r !== undefined);
      if (rhsIn.length === 0) return;
      lhsIn.map(l => {
        rhsIn.map(r => {
          result.push({"lhs": l, "rhs": r});
        });
      });
    });
    return result;
  },
  convKeggReactionEquation: function(raw) {
    let result = [];
    let data = this.convRawTsvJson(raw, header = true);
    data.map(d => {
      let s = d.equation.split(/>/).map(x => x.match(/C\d{5}/g));
      d.lhs = (s[0] === null) ? [null] : s[0];
      d.rhs = (s[1] === null) ? [null] : s[1];
    });
    return data;
  },
  nameInKegg: function(data, klc) {
    data.map(d => {
      let extract = this.subsetData(d.name, klc);
      let idScan = this.pickAnchor(d.name, extract);
      d.idAnchor = idScan.idAnchor;
      d.idOther = idScan.idOther;
    });
  },
  prepareVisData: function(withId, oppose) {
    let result = {"nodes": [], "links": []};
    let nodeSeen = [];
    oppose.map(o => {
      withId.map(w => {
        if (o.lhs === w.idAnchor) o.lhs = w.name;
        if (o.rhs === w.idAnchor) o.rhs = w.name;
      })
      if (nodeSeen.indexOf(o.lhs) === -1) {
        result.nodes.push({"name": o.lhs});
        nodeSeen.push(o.lhs);
      };
      if (nodeSeen.indexOf(o.rhs) === -1) {
        result.nodes.push({"name": o.rhs});
        nodeSeen.push(o.rhs);
      };
      result.links.push({"source": o.lhs, "target": o.rhs});
    });
    withId.map(w => {
      let col = null;
      let regSet = [...new Set(w.regulation)];
      col = regSet.length > 1 ? "cyan" : null;
      if (col === null) {
        if (regSet[0] === "increased") col = "green";
        if (regSet[0] === "decreased") col = "red";
        if (col === null) col = "cyan";
      };
      result.nodes.filter(r => r.name === w.name).map(r => r.colour = col);
    });
    return result;
  },
  cleanNames: function(data, key = "name") {
    let result = [];
    let i = 0;
    data.map(d => {
      let keys = Object.keys(d).filter(x => x !== key);
      let nameClean = d[key].toLowerCase().replace(/\**( \(.+)?$/, '');
      if (nameClean.match(/[\/\+]/) !== null) {
        let nameCleanMany = nameClean.split(/[\/\+]/).map(x => {
          return x.replace(/^\s+|\s+$/g, '');
        });
        nameCleanMany.map(x => {
          result.push(new Object());
          result[i][key] = x;
          keys.map(k => result[i][k] = d[k]);
          i += 1;
        });
      } else {
        result.push(new Object());
        result[i][key] = nameClean;
        keys.map(k => result[i][k] = d[k]);
        i += 1;
      };
    });
    return result;
  },
  runSimulation: function(data, idSvg = "svgVis") {
    let svgElement = document.getElementById(idSvg);
    const width = svgElement.width.baseVal.value;
    const height = svgElement.height.baseVal.value;
    const svg = d3.select("#" + idSvg)
      .attr("viewBox", [-width / 2, -height / 2, width, height]);
    const g = svg.append("g").attr("cursor", "grab");
    const nodes = data.nodes.map(d => Object.create(d));
    const links = data.links.map(d => Object.create(d));
    const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.name))
      .force("charge", d3.forceManyBody())
      .force("x", d3.forceX())
      .force("y", d3.forceY());
    const drag = simulation => {
      function dragStart(event, d) {
        if (!event.active) simulation.alphaTarget(0.4).restart();
        d.fx = d.x;
        d.fy = d.y;
      };
      function dragged(event,d) {
        d.fx = event.x;
        d.fy = event.y;
      };
      function dragEnd(event,d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      };
      return d3.drag()
        .on("start", dragStart)
        .on("drag", dragged)
        .on("end", dragEnd);
    };
    const link = g.append("g")
        .attr("stroke", "#999")
        .attr("stroke-opacity", 0.6)
      .selectAll("line")
      .data(links)
      .join("line")
        .attr("stroke-width", 1);
    const node = g.append("g")
        .attr("stroke", "#fff")
        .attr("stroke-width", 1.5)
      .selectAll("circle")
      .data(nodes)
      .join("circle")
        .attr("r", 5)
        .attr("fill", d => d.colour)
        .call(drag(simulation));
    const text = g.append("g")
        .attr("visibility", "hidden")
        .attr("pointer-events", "none")
        .attr("font-size", "7px")
        .attr("text-anchor", "start")
      .selectAll("text")
      .data(nodes)
      .join("text")
        .text(d => d.name);
    simulation.on("tick", () => {
      link
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);
      node
        .attr("cx", d => d.x)
        .attr("cy", d => d.y);
      text.attr("transform", d => {
        return "translate(" + (d.x + 6) + "," + (d.y + 2.5) + ")";
      });
    });
    svg.call(d3.zoom()
      .extent([[0, 0], [width, height]])
      .scaleExtent([1 / 2, 8])
      .on("zoom", zoomed));
    function zoomed({transform}) {
      g.attr("transform", transform)
    };
    let opacity = 0.33;
    let indexLink = {};
    links.map(l => indexLink[l.source.index + "|" + l.target.index] = true);
    function isConnected(a, b) {
      let c1 = indexLink[a.index + "|" + b.index];
      let c2 = indexLink[b.index + "|" + a.index];
      return (c1 || c2);
    };
    function nodeMouseOver(d, i) {
      link
        .style("opacity", o => {
          let c1 = (o.source.index === i.index);
          let c2 = (o.target.index === i.index);
          return (c1 || c2) ? 1 : opacity;
        })
        .style("stroke", o => {
          let c1 = (o.source.index === i.index);
          let c2 = (o.target.index === i.index);
          return (c1 || c2) ? "blue" : "#999";
        });
      node
        .style("opacity", o => {
          return (isConnected(i, o) || i === o) ? 1 : opacity;
        })
        .style("stroke", o => {
          return (isConnected(i, o) || i === o) ? "blue" : "#fff";
        });
      text
        .style("visibility", o => {
          return (isConnected(i, o) || i === o) ? "visible" : "hidden";
        })
        .style("font-weight", o => {
          return (i === o) ? "bold" : "normal";
        });
    };
    function nodeMouseOut(d, i) {
      link
        .style("opacity", 1)
        .style("stroke", "#999");
      node
        .style("opacity", 1)
        .style("stroke", "#fff");
      text
        .style("visibility", "hidden")
        .style("font-weight", "normal");
    };
    node
      .on("mouseover", (d, i) => nodeMouseOver(d, i))
      .on("mouseout", (d, i) => nodeMouseOut(d, i));
    node.on("click", d => {
      let tmp = API.getData("withId").resurrect().filter(x => {
        return x.name === d.target.textContent;
      });
      API.createData("nodeClicked", tmp)
    });
  },
  subsetData: function(name, keggData) {
    let nPat = name.replace(/(ate|ic acid)$/, "(ate|ic acid)");
    let nRex = new RegExp("^([dl]-)?" + nPat + "$", "gi");
    return keggData.map(k => {
      let anyMatch = k.nameKegg.filter(n => nRex.test(n))
      if (anyMatch.length === 0) return;
      return {"idKegg": k.idKegg, "matchName": anyMatch};
    }).filter(x => x !== undefined);
  }
};

// Cache in the API as "bg"
API.cache("bg", functions);
console.log("Cached bg functions.");
